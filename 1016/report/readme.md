# 어셈블리 프로그래밍 4장 요약

## 1. 명령어 기본 구조
- **Mnemonic (명령어)** : 수행할 동작을 나타내는 키워드 (예: `MOV`, `ADD`, `XCHG`)
- **Destination (목적지)** : 연산 결과가 저장되는 곳
- **Source (소스)** : 가져오는 값이 있는 곳
- **규칙**
  - 두 오퍼랜드는 반드시 같은 크기여야 함
  - 메모리 ↔ 메모리 직접 이동은 불가능 (항상 레지스터를 거쳐야 함)
  - 즉시값(Immediate, 숫자 리터럴)도 소스로 사용 가능

---

## 2. 기억장치와 레지스터
- **레지스터**: CPU 내부의 초고속 기억장치
- **주기억장치**: 메모리(RAM)
- **레지스터 크기**
  - 16비트: AX, BX, CX, DX …
  - 32비트: EAX, EBX, ECX, EDX …
  - 64비트: RAX, RBX, RCX, RDX …
- **세그먼트 레지스터**: CS, DS, SS, ES, FS, GS (64비트 모드에서는 제한적으로 사용)

---

## 3. 데이터 세그먼트와 MOV
- `.data` : 데이터 세그먼트 선언부 (변수 저장 영역)
- `MOV dest, src` : 소스의 값을 목적지에 복사
- 제약:
  - 크기 일치 필수
  - IP/EIP/RIP(명령어 포인터)는 목적지로 사용 불가 (CPU가 직접 관리)

---

## 4. 확장 명령어
- **MOVZX (Zero-Extend)** : 작은 크기의 값을 큰 레지스터로 옮길 때 상위 비트를 0으로 채움
- **MOVSX (Sign-Extend)** : 작은 크기의 값을 큰 레지스터로 옮길 때 상위 비트를 부호 비트로 채움 (C언어의 부호 확장과 동일)

---

## 5. 플래그 관련 명령
- **LAHF** : 플래그 레지스터의 하위 8비트를 AH에 로드
- **SAHF** : AH의 값을 플래그 레지스터 하위 8비트에 저장
- **XCHG** : 두 오퍼랜드의 값을 교환
- **INC / DEC** : +1, -1 (Carry 플래그는 건드리지 않음)
- **NEG** : 2의 보수 취해 부호 반전

---

## 6. 주요 플래그
- **CF (Carry)** : 자리올림/자리내림 발생
- **ZF (Zero)** : 결과가 0인지 여부
- **SF (Sign)** : 결과 부호
- **OF (Overflow)** : 부호 있는 연산에서 오버플로우 발생
- **PF (Parity)** : 결과의 하위 바이트에 1이 짝수 개면 1
- **AF (Auxiliary Carry)** : BCD 연산용, 4비트 자리올림

---

## 7. 데이터 정렬과 접근
- **ALIGN n** : 데이터를 n바이트 경계에 맞춤 (짝수 주소 접근이 홀수보다 빠름)
- **PTR 연산자**
  - `BYTE PTR`, `WORD PTR`, `DWORD PTR` 등으로 크기 지정
  - 예: `mov al, BYTE PTR myDouble`
- **TYPE / LENGTHOF / SIZEOF**
  - TYPE: 자료형 크기 (BYTE=1, WORD=2, DWORD=4 …)
  - LENGTHOF: 배열 원소 개수
  - SIZEOF: 전체 바이트 크기 (= TYPE × LENGTHOF)

---

## 8. 주소 지정 방식
- **직접 오프셋**: `[array+2]` → 배열의 특정 위치
- **간접 주소 지정**: `mov al, [esi]` (ESI가 가리키는 주소)
- **인덱스 + 스케일**: `[esi+ecx*4]` → 배열 인덱스 접근
- **주의**: 간접 접근 시 반드시 `BYTE PTR`, `WORD PTR` 등 크기 지정 필요

---

## 9. 반복과 제어
- **LOOP** : CX(16비트) 또는 ECX(32비트)를 카운터로 사용
  - 실행 시 ECX를 1 감소시키고, 0이 아니면 지정한 레이블로 점프
  - 루프 안에서 CX/ECX를 함부로 건드리면 안 됨
- **JMP / 조건 분기** : 플래그 상태에 따라 분기

---

## 핵심 요약
- MOV는 메모리 ↔ 레지스터 간 이동만 가능
- MOVZX/MOVSX는 확장 방식이 다름 (제로 vs 부호)
- 플래그는 연산 결과 상태를 반영하며 조건 분기에 활용됨
- 데이터 정렬은 성능에 영향, PTR/TYPE/LENGTHOF/SIZEOF로 크기 관리
- 주소 지정은 직접/간접/인덱스 방식이 있으며, 루프는 ECX 기반으로 반복 제어
