# 어셈블리 언어 리뷰 질문 및 해설

## 1. 세 가지 명령어 기호의 예시
세 가지 명령어 기호의 예시로 MOV, ADD, SUB가 있다.

## 2. 호출 규약(Call Convention)이란?
호출 규약이란 함수 호출 시 인자를 전달하고 반환값을 처리하는 방식. 어셈블리에서는 stdcall, cdecl 같은 키워드로 선언하며, 스택 정리 책임이 달라진다.

## 3. 스택 공간 예약 방법
SUB ESP, n 명령어로 스택 포인터를 감소시켜 n 바이트 공간을 확보

## 4. ‘Assembler Language’가 부정확한 이유
올바른 용어는 ‘Assembly Language’이고, ‘Assembler’는 코드를 기계어로 번역하는 프로그램을 의미한다.

## 5. Big Endian vs Little Endian
Big Endian: 가장 중요한 바이트(MSB)를 먼저 저장  
Little Endian: 가장 덜 중요한 바이트(LSB)를 먼저 저장  
기원: 1980년 Danny Cohen이 Jonathan Swift의 걸리버 여행기에서 유래한 용어를 컴퓨터 과학에 도입했다

## 6. 기호 상수를 사용하는 이유
유지보수와 가독성을 높이며, 코드 변경 시 일괄 수정이 가능해 오류를 줄일 수 있다.

## 7. 소스 파일 vs 리스팅 파일
소스 파일: 개발자가 작성한 코드 (.asm)  
리스팅 파일: 어셈블러가 생성한 코드 + 주소 + 기계어 (.lst)

## 8. 데이터 라벨 vs 코드 라벨
데이터 라벨: 변수나 상수에 사용  
코드 라벨: 실행 위치를 지정 (예: 점프 대상)

## 9. (True/False): 식별자는 숫자로 시작할 수 없다  
True

## 10. (True/False): 0x3A는 16진수 리터럴로 표현 가능  
True

## 11. (True/False): 어셈블리 지시문은 런타임에 실행된다  
False, 컴파일 타임에 의해 처리된다.

## 12. (True/False): 지시문은 대소문자 혼용 가능  
True

## 13. 어셈블리 명령의 네 가지 기본 구성 요소
라벨(label)  
명령어(mnemonic)  
피연산자(operands)  
주석(comment)

## 14. (True/False): MOV는 명령어 기호의 예시이다  
True

## 15. (True/False): 코드 라벨은 콜론(:)으로 끝나고 데이터 라벨은 그렇지 않다  
False

## 16. 블록 주석 예시
COMMENT !  
 This line is a comment.  
 This line is also a comment.  
!

## 17. 숫자 주소를 사용하지 말아야 하는 이유
변수 접근 시 숫자 주소를 사용하지 말아야 하는 이유는 유지보수가 어렵고, 코드 가독성이 떨어지며, 주소 변경 시 오류 발생 가능성이 높습니다.

## 18. ExitProcess에 전달해야 하는 인자
32비트 정수값(DWORD) 전달

## 19. 프로시저 종료 지시문
RET 또는 ENDP

## 20. END 지시문의 식별자 역할 (32비트 모드)
프로그램의 시작 지점을 지정한다. 예시로 main이 있다.

## 21. PROTO 지시문의 목적
프로시저의 원형을 선언하여 호출 시 인자와 반환값을 명확히 한다.

## 22. (True/False): 오브젝트 파일은 링커가 생성한다  
False, 오브젝트 파일은 링커가 아닌 어셈블러가 생성한다.

## 23. (True/False): 리스팅 파일은 어셈블러가 생성한다  
True

## 24. (True/False): 링크 라이브러리는 실행 파일 생성 직전에 추가된다  
True

## 25. 32비트 부호 있는 정수 변수 생성 지시문  
SDWORD

## 26. 16비트 부호 있는 정수 변수 생성 지시문  
SWORD

## 27. 64비트 부호 없는 정수 변수 생성 지시문  
QWORD

## 28. 8비트 부호 있는 정수 변수 생성 지시문  
SBYTE

## 29. 10바이트 BCD 변수 생성 지시문  
TBYTE
