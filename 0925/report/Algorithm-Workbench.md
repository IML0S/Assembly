# ğŸ› ï¸ Algorithm Workbench ë¬¸ì œ í’€ì´ (1~15ë²ˆ)

## ë¬¸ì œ 1  
**Q: Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.**  
A: 25ë¥¼ 10ì§„ìˆ˜, 2ì§„ìˆ˜, 8ì§„ìˆ˜, 16ì§„ìˆ˜ í˜•ì‹ìœ¼ë¡œ ë‚˜íƒ€ë‚´ëŠ” 4ê°œì˜ ì‹¬ë³¼ë¦­ ìƒìˆ˜ë¥¼ ì •ì˜í•œë‹¤.  
```asm
DEC25 = 25  
BIN25 = 11001b  
OCT25 = 31o  
HEX25 = 19h  
```

## ë¬¸ì œ 2  
**Q: Find out, by trial and error, if a program can have multiple code and data segments.**  
A: ë‹¨ìˆœíˆ .dataë¥¼ ì—¬ëŸ¬ ê°œ ê°€ì§ˆ ìˆœ ì—†ì§€ë§Œ  
```asm
data1 SEGMENT
a1 DWORD 1234h
data1 ENDS

data2 SEGMENT
a2 DWORD 5678h
data2 ENDS
```
ì™€ ê°™ì´ SEGMENTì™€ ENDSë¥¼ ì‚¬ìš©í•˜ë‹ˆ ë‹¤ìˆ˜ì˜ ë°ì´í„° ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì§€ì •í•˜ê³ ë„ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ì˜€ë‹¤.  
ì½”ë“œ ì„¸ê·¸ë¨¼íŠ¸ ì—­ì‹œ ë§ˆì°¬ê°€ì§€ë¡œ ê°€ëŠ¥í•˜ì§€ëŠ” ì•Šì§€ë§Œ  
```asm
code1 SEGMENT
main PROC
    ; main ë£¨í‹´
    ret
main ENDP
code1 ENDS

code2 SEGMENT
other PROC
    ; ë³´ì¡° ë£¨í‹´
    ret
other ENDP
code2 ENDS
```
ì™€ ê°™ì€ í˜•ì‹ìœ¼ë¡œ í•œì •ëœ ì¡°ê±´ì—ì„  ì‹¤í–‰ì´ ê°€ëŠ¥í•˜ë‹¤ê³  í•œë‹¤. (Copilot ìë¬¸)

## ë¬¸ì œ 3  
**Q: Create a data definition for a doubleword that stored it in memory in big endian format.**  
A: DWORDë¥¼ ë¹… ì—”ë””ì•ˆ í˜•ì‹ìœ¼ë¡œ ì €ì¥í•˜ë„ë¡ ë°ì´í„°ë¥¼ ì •ì˜í•œë‹¤. MASMì€ ë¹… ì—”ë””ì•ˆì„ ë”°ë¡œ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ìˆ˜ë™ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤.  
```asm
.data
big BYTE 12h, 34h, 56h, 78h
```

## ë¬¸ì œ 4  
**Q: Find out if you can declare a variable of type DWORD and assign it a negative value. What does this tell you about the assemblerâ€™s type checking?**  
A: DWORDì— ìŒìˆ˜ê°’ì„ ë„£ì–´ ê²°ê³¼ë¥¼ ì•Œì•„ë³¸ë‹¤.  
```asm
mov DWORD PTR DS:[402000], -1
```
ê²°ê³¼ 'FF FF FF FF'ë¡œ ì €ì¥ëœë‹¤.  
DWORDëŠ” ë¶€í˜¸ ì—†ëŠ” 32ë¹„íŠ¸ ì •ìˆ˜í˜•ì´ê¸° ë•Œë¬¸ì— ìŒìˆ˜ë¥¼ í• ë‹¹í•˜ë©´ 2ì˜ ë³´ìˆ˜ í˜•íƒœë¡œ ë³€í™˜ë˜ì–´ ì €ì¥ëœë‹¤.  
ëŒ€ë¶€ë¶„ì˜ ì–´ì…ˆë¸”ëŸ¬ëŠ” íƒ€ì…ì„ ì—„ê²©í•˜ê²Œ ê²€ì‚¬í•˜ì§€ ì•Šê³ , ì˜¤ë¥˜ë¥¼ ë„ìš°ì§€ ì•Šê¸° ë•Œë¬¸ì— í”„ë¡œê·¸ë˜ë¨¸ì˜ ì£¼ì˜ê°€ í•„ìš”í•¨ì„ ì•Œ ìˆ˜ ìˆë‹¤.

## ë¬¸ì œ 5  
**Q: Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?**  
A: eax ë ˆì§€ìŠ¤í„°ì— 5, edx ë ˆì§€ìŠ¤í„°ì— 5ë¥¼ ë”í•˜ëŠ” ëª…ë ¹ì–´ë¥¼ í¬í•¨í•œ í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ê³ , ë¦¬ìŠ¤íŒ… íŒŒì¼ì„ í™•ì¸í•œë‹¤.  
```asm
.386
.MODEL FLAT, STDCALL
.STACK 4096

.code
main PROC
    add eax, 5  
    add edx, 5  
    ret
main ENDP
END main
```
í•´ë‹¹ ì½”ë“œì˜ ë¦¬ìŠ¤íŒ… íŒŒì¼ ì¤‘  
```asm
00000000  83 C0 05    ; add eax, 5  
00000003  83 C2 05    ; add edx, 5
```
addì™€ ìˆ«ì 5ì— í•´ë‹¹í•˜ëŠ” 83ê³¼ 05ëŠ” ë™ì¼í•˜ë‹¤.  
ë°˜ë©´ ë ˆì§€ìŠ¤í„°ì— í•´ë‹¹í•˜ëŠ” ë‘ ë²ˆì§¸ ë°”ì´íŠ¸ëŠ” ë‹¤ë¥´ê²Œ ë‚˜íƒ€ë‚œë‹¤.  
ì´ëŠ” ì–´ì…ˆë¸”ëŸ¬ê°€ ì‚¬ìš©í•˜ëŠ” ë ˆì§€ìŠ¤í„°ì— ë”°ë¼ ë¨¸ì‹  ì½”ë“œê°€ ë‹¬ë¼ì§„ë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•˜ë©°, ì–´ì…ˆë¸”ë¦¬ ì–¸ì–´ê°€ í•˜ë“œì›¨ì–´ì™€ ë°€ì ‘í•˜ê²Œ ì—°ê²°ë˜ì–´ ìˆìŒì„ ë³´ì—¬ì¤€ë‹¤.

## ë¬¸ì œ 6  
**Q: Given the number 456789ABh, list out its byte values in little-endian order.**  
A: AB 89 67 45

## ë¬¸ì œ 7  
**Q: Declare an array of 120 uninitialized unsigned doubleword values.**  
A:  
```asm
.data
myArray DWORD 120 DUP(?)
```

## ë¬¸ì œ 8  
**Q: Declare an array of byte and initialize it to the first 5 letters of the alphabet.**  
A:  
```asm
.data
array BYTE "ABCDE"
```

## ë¬¸ì œ 9  
**Q: Declare a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value. (Hint: Refer to integer ranges in Chapter 1.)**  
A:  
```asm
.data
val2 SDWORD -2147483648
```

## ë¬¸ì œ 10  
**Q: Declare an unsigned 16-bit integer variable named wArray that uses three initializers.**  
A:  
```asm
.data
wArray WORD 1234h, 5678h, 9876h
```

## ë¬¸ì œ 11  
**Q: Declare a string variable containing the name of your favorite color. Initialize it as a nullterminated string.**  
A:  
```asm
.data
favColor BYTE "CYAN", NULL
```

## ë¬¸ì œ 12  
**Q: Declare an uninitialized array of 50 signed doublewords named dArray.**  
A:  
```asm
.data
dArray SDWORD 50 DUP(?)
```

## ë¬¸ì œ 13  
**Q: Declare a string variable containing the word â€œTESTâ€ repeated 500 times.**  
A:  
```asm
.data
msg BYTE 500 DUP("TEST"), "$"
```

## ë¬¸ì œ 14  
**Q: Declare an array of 20 unsigned bytes named bArray and initialize all elements to zero.**  
A:  
```asm
.data
bArray BYTE 20 DUP(0)
```

## ë¬¸ì œ 15  
**Q: Show the order of individual bytes in memory (lowest to highest) for the following doubleword variable: val1 DWORD 87654321h**  
A: 21h 43h 65h 87h
